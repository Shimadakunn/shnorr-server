import requests
import json
from Crypto.Util.number import inverse
import random

def get_proof():
    response = requests.get('http://localhost:5001/vulnerable-proof')
    return json.loads(response.text)

# Get two proofs
proof1 = get_proof()
proof2 = get_proof()

# Extract values
p = proof1['p']
g = proof1['g']
y = proof1['y']
r = proof1['r']  # Same for both proofs
s1 = proof1['s']
e1 = proof1['e']
s2 = proof2['s']
e2 = proof2['e']

# Add debugging information
print(f"e1: {e1}")
print(f"e2: {e2}")
print(f"e1 - e2: {e1 - e2}")
print(f"p - 1: {p - 1}")

# Check if e1 - e2 is invertible
if e1 == e2:
    print("Error: e1 and e2 are equal. Cannot recover the private key.")
else:
    try:
        x = ((s1 - s2) * inverse(e1 - e2, p-1)) % (p-1)

        # Verify the calculated private key
        if pow(g, x, p) == y:
            print(f"Private key successfully recovered: {x}")
        else:
            print("Failed to recover the private key")

        # Demonstrate the ability to generate valid proofs
        def generate_proof(message):
            k = random.randint(1, p-2)
            r = pow(g, k, p)
            e = int.from_bytes(message.encode(), 'big') % (p-1)
            s = (k + e * x) % (p-1)
            return {'r': r, 'e': e, 's': s}

        # Generate a proof for a custom message
        custom_proof = generate_proof("Hello, I've hacked the system!")
        print(f"Custom proof: {custom_proof}")
    except ValueError:
        print("Error: e1 - e2 is not invertible modulo p-1. Try getting new proofs.")
